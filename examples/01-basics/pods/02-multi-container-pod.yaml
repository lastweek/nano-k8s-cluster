# Multi-Container Pod - Sidecar Pattern
#
# This example shows a pod with two containers:
# 1. Main application (nginx) serving HTTP
# 2. Sidecar (busybox) tailing the logs and monitoring the app
#
# The containers share:
# - Network namespace (can reach each other via localhost)
# - Storage volume (emptyDir for log sharing)
#
# This pattern is commonly used for:
# - Log shipping (Fluentd, Filebeat)
# - Monitoring (Prometheus exporters)
# - Proxies (Envoy, Istio)
#
# Usage:
#   kubectl apply -f multi-container-pod.yaml
#   kubectl logs multi-container-pod -c main-app      # View nginx logs
#   kubectl logs multi-container-pod -c sidecar      # View sidecar logs
#   kubectl delete pod multi-container-pod

apiVersion: v1
kind: Pod
metadata:
  name: multi-container-pod
  labels:
    app: multi-container
    pattern: sidecar
spec:
  # Shared volume for both containers
  volumes:
  - name: shared-logs
    emptyDir:
      medium: Memory  # RAM-backed for performance

  containers:
  # Main application container
  - name: main-app
    image: nginx:1.25
    ports:
    - name: http
      containerPort: 80
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
    # Liveness probe to check if app is healthy
    livenessProbe:
      httpGet:
        path: /
        port: 80
      initialDelaySeconds: 3
      periodSeconds: 3

  # Sidecar container for log monitoring
  - name: sidecar
    image: busybox:1.36
    # Keeps the log monitoring running
    command: ["/bin/sh"]
    args:
      - -c
      - |
        echo "Sidecar: Starting log monitor..."
        while true; do
          if [ -f /var/log/nginx/access.log ]; then
            echo "=== Log entry at $(date) ==="
            tail -n 1 /var/log/nginx/access.log 2>/dev/null || echo "Waiting for logs..."
          fi
          sleep 10
        done
    volumeMounts:
    - name: shared-logs
      mountPath: /var/log/nginx
      readOnly: true
    # Sidecar doesn't need a liveness probe
    # If it fails, the whole pod restarts
